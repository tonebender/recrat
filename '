{-# LANGUAGE OverloadedStrings #-}

module Main where

import Options.Applicative
import Network.Wreq (getWith, defaults, params, param, responseBody)
import Control.Lens
import Data.Text.Internal (Text)
import Data.Aeson.Lens (_String, key)
import qualified Data.Text as T
import qualified Text.Parsec as P


data Inputargs = Inputargs
    { optAlbum :: Text }

-- Parser for command line arguments
myParser :: Parser Inputargs
myParser = Inputargs
    <$> strOption
        (long "title"
        <> metavar "ALBUMTITLE"
        <> help "The album title to get ratings for")

-- Help text and info for command line
myDescription :: ParserInfo Inputargs
myDescription = info (myParser <**> helper)
    ( fullDesc
      <> progDesc "Lists music albums by artist and rating"
      <> header "album-ratings - find ratings for music albums" )


wikipediaApiUrl :: String
wikipediaApiUrl = "https://en.wikipedia.org/w/api.php"

-- TODO: Handle several results, like different http response codes etc.
requestWikipage :: Text -> IO (Maybe Text)
requestWikipage page = do
    let urlParams = [ ("action", "parse"), ("format", "json"), ("prop", "wikitext"), ("redirects", "1") ]
    let opts = defaults & params .~ urlParams & param "page" .~ [page]
    r <- getWith opts wikipediaApiUrl
    return $ r ^? responseBody . key "parse" . key "wikitext" . key "*" . _String


-- TODO: Replace getRatingTag and getRatingsInAlbumPage with parsers

-- Look for the starting string for Music ratings or Album ratings
-- in the wiki text and return it if found; Nothing if none found.
getRatingTag :: Text -> Maybe Text
getRatingTag wikiText =
    let music = "{{Music ratings\n"
        album = "{{Album ratings\n" in
    if T.isInfixOf music wikiText then
        Just music
        else if T.isInfixOf album wikiText then
        Just album
        else Nothing


-- Get the ratings block out of the wiki text, starting
-- with the Music/Album tag (see above) and ending with "}}\n";
-- return Nothing if failed.
getRatingsInAlbumPage :: Text -> Maybe Text
getRatingsInAlbumPage wikiText =
    case getRatingTag wikiText of
        Nothing -> Nothing
        Just tag -> let xs = drop 1 $ T.splitOn tag wikiText in
            case xs of
                [] -> Nothing
                x:_ -> let a = take 1 $ T.splitOn "}}\n" x in
                    case a of
                        [] -> Nothing
                        b:_ -> Just b

data Score = Score
    { percentage :: Int
    , score :: Double
    , maxi :: Double
    , title :: Text
    , ref :: Text
    } deriving (Show)

reviewParser :: P.Parsec Text () [Score]
reviewParser = P.many $ do
    P.char '|' >> P.spaces >> P.string "rev" >> P.many1 P.digit >> P.spaces >> P.char '=' >> P.spaces
    titl <- P.manyTill P.anyChar P.endOfLine
    P.char '|' >> P.spaces >> P.string "rev" >> P.many1 P.digit >> P.string "Score" >> P.spaces >> P.char '=' >> P.spaces
    (scr, maxScr) <- scoreInRatingTemplParser <|> scoreAsFragmentParser <|> scoreAsLetterParser
    reftag <- refParser
    return $ Score (scr / maxScr) (score scr) (maxi scr) (T.pack titl) (T.pack reftag)

-- TODO: Make these sub parsers return something shorter than Score?
-- TODO: Change read to readMaybe or so
-- Parser for scores that look like this: {{Rating|3.5|5}}
scoreInRatingTemplParser :: P.Parsec Text () (Double, Double)
scoreInRatingTemplParser = do
    _ <- (P.string "{{Rating|") <|> P.string "{{rating|"
    scr <- P.many1 (P.digit <|> P.char '.')
    _ <- P.char '|'
    mx <- P.many1 P.digit
    _ <- P.string "}}" -- >> P.endOfLine
    return (read scr, read mx)

-- Parser for scores that look like this: 5.5/10
scoreAsFragmentParser :: P.Parsec Text () (Double, Double)
scoreAsFragmentParser = do
    scr <- P.many1 $ P.digit <|> P.char '.'
    _ <- P.char '/'
    mx <- P.many1 $ P.digit <|> P.char '.'
    return (read scr, read mx)

-- Parser for letter scores, from E- to A+, which we
-- translate to a number between 1 and 15
scoreAsLetterParser :: P.Parsec Text () (Double, Double)
scoreAsLetterParser = do
    letter <- P.oneOf "ABCDE"
    let l = case letter of
         'E' -> 2
         'D' -> 5
         'C' -> 8
         'B' -> 11
         'A' -> 14
         _ -> 0
    sign <- P.optionMaybe (P.oneOf "+-âˆ’")
    let s = case sign of
         Just '+' -> 1
         Just _ -> (-1)
         Nothing -> 0
    return (l + s, 15)

-- Parser that gets everything inside <ref></ref> that follows all scores
refParser :: P.Parsec Text () String
refParser = P.string "<ref" *> (P.string ">" <|> P.manyTill P.anyChar (P.char '>')) *> P.manyTill P.anyChar (P.string "</ref>") <* P.endOfLine


-- main :: IO ()
-- main = do
--     inputargs <- execParser myDescription
--     let albumTitle = optAlbum inputargs
--     wikitext <- requestWikipage albumTitle
--     case wikitext of
--         Nothing -> do putStrLn $ show $ "Failed to fetch wikipedia page for '" <> albumTitle <> "'"
--         Just w -> do
--             let ratings = getRatingsInAlbumPage w
--             case ratings of
--                 Nothing -> do putStrLn "Could not extract Music/Album ratings from wiki page. Perhaps there are none?"
--                 Just rats -> do
--                     let rev = P.parse reviewParser "(source)" rats
--                     case rev of
--                         Right r -> putStrLn $ show r
--                         Left err -> putStrLn $ "Parse error:" ++ show err

main :: IO ()
main = do
    mock <- readFile "mock_rocks.txt"
    let ratings = getRatingsInAlbumPage (T.pack mock)
    case ratings of
        Nothing -> do putStrLn "Could not extract Music/Album ratings from wiki page. Perhaps there are none?"
        Just rats -> do
            let rev = P.parse reviewParser "(source)" rats
            case rev of
                Right r -> do
                    putStrLn $ show r
                    putStrLn $ show $ length r
                Left err -> putStrLn $ "Parse error:" ++ show err
